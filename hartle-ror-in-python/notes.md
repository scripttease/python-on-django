# Following a Rails Tutorial with Python

Following a tutorial in a language you know and converting it as you go along into a language that you *don't* know, can, I am assured, be a good way to learn a new language.

I am following the [Hartle Rails Tutorial](https://www.railstutorial.org/book/toy_app#sec-planning_the_application) In Python and I am starting from chapter 2.1 because I covered installation in *../notes.md* following the DjangoGirls Guide. I may tidy this all up later...

## 2.1 Planning the application

Generate the application skeleton (and virtual environment which is required in Python and is similar to bundler I believe)

```sh
# In your project folder create a  virtual environment
python3 -m venv venv

# Activate the virtual environment. note that for a standard bash shell, leave off .fish
source venv/bin/activate.fish

python3 -m pip install --upgrade pip

# Create a file that allows Django to be installed and run
echo "Django~=2.0.6" >> requirements.txt

# Install Django using the requirements file
pip install -r requirements.txt

# Start a Django project
django-admin startproject ror_in_python_project .
```
**NB This last command scaffolds a project. See below for scaffolding an app within that**

### Static files path

**NB _settings.py_ is like a Gemfile**

At the end of the settings.py file add the following ine:

```py
STATIC_ROOT = os.path.join(BASE_DIR, 'static')
```


**This is the actual part where we scaffold the toy app**

```sh
python manage.py startapp toy_app
```

### Listing 2.1 A Gemfile... in Python is *settings.py*
In generating the project, we have already autogenerated something like a gemfile. In it all the Python libraries and middleware are listed under `INSTALLED_APPS` and `MIDDLEWARE`

Our App we just started actually needs to be put under the list of installed apps too, like so:

```py
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'toy_app',
]
```

### Bundle install... 
We don't need to do this because running the app takes care of installing the libraries etc. BUT interestingly, Django comes with built in OAUTH. This is really cool but means that when we run the server it will tell us we have stuff in our database (OAUTH admin stuff from a Django Library) that we didn't put there and hasn't been migrated... Its ok to ignore it for now...

### Figure 2.1... versiona control and deploy all ignored.
This whole project is in version control on Github. I'm going to leave out these steps. Also deploying to Heroku... BUT IF YOU DEPLOY:

**BEFORE YOU COMMIT**
Go to *settings.py* and delete the Secret Key!!!
You can make it into an environment variable like so:

```py
SECRET_KEY = os.environ.get('SECRET')
```
And every time you want to deploy, you can make sure that your sekret key in in your environment (shell) variables by running:

```sh
export SECRET_KEY=<your-secret-key-here>
```

this makes a key available for this session and to automate this you will need a shell script or another way of doing secrets but that can come later

**NB Some of  the directories and filenames in my previous DjangoGirls tutorials and examples were renamed with an 'x' preceeding the file name so that django and Heroku don't look there for framework/etc and I am convinced that this would have been more sensibly done by moving everything to a new repo in hidsight or that there was a much better way to do this (ie put stuff in the .gitignore) but I didn't think of that...**

### Listing 2.2
This just puts something on our page when we run the server (at the moment all we would see is the Django landing page)

In rails what you see on a page that you request is controlled by, well, controllers. In Python it is handled by *views.py*

```python
from django.shortcuts import render

def hello(request):
    return render(request, 'toy_app/hello.html', {})
```
 Note that we can't just render html. Python's render shortcut requires a template. In the *toy_app* directory we need to create the following folders and file *templates/toy_app/hello.html*

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title></title>
  </head>
  <body>
    <p>hello world</p>
  </body>
</html>

```

### Listing 2.3 Setting the root route

In *urls.py* add this import to the top of the file
```py
from django.urls import path, include
from django.contrib import admin
```
Then in the `urlpatterns` list add:

```py
    path('', include('toy_app.urls')),
```
Then (so things are kept neat if there are other apps etc, go into the toy_app directory and create *toy_app/urls.py* as follows:

```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.hello, name='hello'),
]
```

Now check it works... 

```sh
python manage.py runserver
```

you'll see some error messages about migrating things like admin etc BUT if you point your browser to `http://localhost:8000/` you should see the text 'hello world'.

## 2.1.1 A toy model for users

A cool thing about Django is that it assumes you want users and OAUTH and logins and passwords... so you just get them out of the box. This is that admin library that has been mentioned. So to get all that stuff all you do is make and run your migrations and it will appear... so actually no code here... on to the next step

## 2.1.2 A toy model for microposts

All that the ROR tutorial wants you to have in this model is a user, and content as a text field. So lets model this in *models.py*

```py
from django.db import models

class Micropost(models.Model):
    user_id = models.ForeignKey('auth.User', on_delete=models.CASCADE)
    text = models.TextField()

    def publish(self):
        self.save()
```

On line 1 we import the Django db models library. We define our model as a class called MicroPost which inherits from the imported Django models.Model. The only things a model needs now are fields. In a database this would look like a table called Microposts with two columns, one called user_id and one called text. In Python you have to then assign a database field type for the database (and these come from the Field class and you can see types [here](https://docs.djangoproject.com/en/2.1/ref/models/fields/#model-field-types)

In the case of the column I've called user_id (could be called author too if preferred) the field type is actually going to be a user and we already *have* users model provided by the admin/auth library, so we want this column to be linked to another table - the user table. To do this we use a models.ForeignKey field defined as `class ForeignKey(to, on_delete, **options)[source]` and use the standard kind of CASCADE delete. Because the User class is in the auth library not in this file we need to refer to it as `auth.User' 

The next column is simpler, it is just called text and is a TextField in the database.

I have used a very simple publish methid of just saving the instance (self).

## Listing 2.4: Migrating the database

```sh
# admin and auth migrations
python manage.py makemigrations
python manage.py migrate
# our migrations
python manage.py makemigrations toy_app
python manage.py migrate toy_app

# run server

```sh
python manage.py runserver
```

# 2.1.1 A User Tour

Rails uses scaffold to generate their user even before they make their mocropost model. The scaffolded user comes with an awful lot including views and so on which we get with Auth and Admin libraries in Python too. But we don't actually get a list of all users and so on unless we are admins.... for the sake of completeness I will recreate these below.

For example to create a page a '/users' which is a list of all users: 

### Step 1 create a route

in *toy_app/urls.py*
```py
    path('users', views.user_list, name='user_list'),

```
A minimal view could now be created in *blog/views.py* as follows:

### Step 2 create a view:

in *toy_app/views.py*

```py
from django.shortcuts import render
from django.contrib.auth.models import User

def user_list(request):

    users = User.objects.all

    return render(request, 'toy_app/user_list.html', {'users': users})
```

### Step 3 create a template and base template:

*toy_app/templates/base.html*:

*toy_app/templates/toy_app.html*:

We don't know if we have done this rigt becayuse as yet we have no users so we can go to the built in admin page that Auth and Admin provide and create some but first we need a superuser

```
### Step 4 Add users

```sh
python manage.py createsuperuser
```

fill in your name and password and email at the prompts then refresh the page [http://localhost:8000/users](http://localhost:8000/users)

You can add users from the admin site which is generatetd by Django or from the console (shell) or directly by interfacing with the database:

```sh
sqlite3 db.sqlite3
```

You can also view the tables here to give you an idea of what the auth_user actually looks like since the docs are all over the place and its autogenerated and the source code is huge... try the following commands:

```sh
sqlite3 db.sqlite3

.tables

.schema tablename

select * from tablename;

```

The `.tables` command has told us that the table we want is probably `auth_user` and fields include *first_name, last_name* and *date_joined*...


Now that we have a /users aka **index** page (check out the html templates and the notes in the previous DjangoGirls tutorial for how they fit together and using Djangos template language and tags) we can also add a **show, new** and **edit** page in a similar way. All I have done is follow the steps above and used my django girls tutorial notes to jog my memory where necessary, but we did all of these for Posts in that tutorial.


### User Show
#### Step 1 Route
in *urls.py*

```py
    path('user/<int:pk>', views.user_show, name='user_show'),
```
#### Step 2 Create a view (aka controller)

in *views.py*
```py
def user_show(request, pk):
    user = User.objects.get(pk=pk)

    return render(request, 'toy_app/user_show.html', {'user': user})
```

nb this would also work and hadles the error for when a url with no user is selected:

```py
def user_show(request, pk):
    user = get_objects_or_404(User, pk=pk) 

    return render(request, 'toy_app/user_show.html', {'user': user})
```

#### Step 3 create template
in *templates/toy_app/user_show.html*

### Create user new
nb this might not work because of auth etc... for example I imagine that as a superuser logged in it will work for me but may not work for anyone else... we will see

#### Url
```py
    path('user/new', views.user_new, name='user_new'),
```

#### view
This requires a file called forms and a library from Django that makes forms for editing and adding model objects easier. Our form for this case (use edit, user new) will be called UserForm

NOTE that the user_new.html will not actually need to exist instead you can jsut use user_edit so I have made this is this step too. It is imortant to note that on examining the database I clearly can add a user but I vcannot give them a password that is encrypted... this is a problem... so generally its probably best to leave the 'new'user to Django... After all, so far all of the user stuff we saw in Rails was generated just as it was by Auth in Django

**NB The Python templating lang used in the views is called Ginger**

### 2.2.2 MTV (MVC) in action:

describing the results of a typical browser hit; a visit to the users (all) page at /users, in terms of Djangos MVC which is basically MTV or MVT...

1. A request from a browser hits the Django router which despatches the request to the relevant view action, based on the URL in *urls.py*. In this case, if we request /users from the browser we are sent to the action `user_list` in the *views.py*.These actions usually correlate to a view, but don't have to... for example, what about the REST http request DELETE method? We don't have that made yest (althogh it does come with User_auth anyway... but what if we needed to make it ourselves? The http request methids are GET, POST, PATCH and DELETE and we have only used get and POST so far.

however you dont often actually use the DELETE methid - it doesn't support a payload - youd use a POST or GET or whatever with an action in the view... Anyway, the point is that I haven't shown how to do this here YET may come back to it.

### Listing 2.10 template for user index

our user_list.html doesnt look much like the one in 2.10 but we can make it so that it does. Still not sure how to do the delete without the scaffolding - but this may come later.


## 2.3.1 Microposts

In the rails tutorial this model, all the views and so on are generated with scaffolding. There is no built in way to do this in Django and although there are libraries that do this I do not trust them so we will just do it all from scratch for an exercise

The mocropost model simply has a user, which will be linked using a foreign key to our auth_user resource and a content which is a text field. In *models.py* we have already made this, now we need to add it to our views etc I am also going to add a created_date and a published date for if we edit it.

In order to add this model to our database:

```sh
python manage.py makemigrations toy_app
python manage.py migrate toy_apjp
```

Now make the index, show, new, create, and edit actions (ignore update and destroy)

### First make the routes in *urls.py*
### Make your 'controller' actions in *views.py* after you first import the model:

```py
from .models import Micropost
```

Make views similar to the user views and do the same with templates...

### Forms: you will need a new MicroPost form in *forms.py*


**Remember to import your micropost model into _admin.py_**

```py
from .models import Micropost

admin.site.register(Micropost)
```

At this point I keep running into the wall of being logged in etc. So I am going to go back to the tutorial and look at the extension here [https://tutorial-extensions.djangogirls.org/en/homework/](https://tutorial-extensions.djangogirls.org/en/homework/)

## Deleting a micropost

*urls.py*

```py
from django.conf.urls import url

# In the patterns list
url(r'^post/(?P<pk>\d+)/remove/$', views.post_remove, name='post_remove')
```
Normally we have the prefix `path` but if we don't necessarily want an actual page, or we haven't imported the path library, we can use `url`. The preceding `r` is optional but it is a good idea to include it because it tells Django to look for an exact match to the url. Inside the quote marks we have the actual url, howvere the `^` and `$` are markers to show the interpreter where the string to match begins and ends. Next we have post followed by a regex which captures the number that comes after post/ and assigns it to `pk` and pass it to the view. Note that I am not sure why the `/` do not have to be escaped in this regex...
[https://docs.djangoproject.com/en/1.11/topics/http/urls/#named-groups](https://docs.djangoproject.com/en/1.11/topics/http/urls/#named-groups) and [stackoverflow question about it](https://stackoverflow.com/questions/47246068/django-forms-what-does-ppk-d-signify)

In *views.py*

```py
def micropost_remove(request, pk):
    micropost = get_object_or_404(Micropost, pk=pk)
    micropost.delete()
    return redirect('micropost_list')
```

In *post_show.html*

```html

<a class="btn btn-default" href="{% url 'micropost_remove' pk=micropost.pk %}"><span class="glyphicon glyphicon-remove"></span></a>
```

## 2.3.2 Microposts - validation

Ok so now we *are* up to date we know how to destroy a post (and a user if we had made that resource ourselves). Next, validation. First we will restrict the length of  micropost to 140 characters.

In *models.py* in my micropost model I changed the content line to this

```py
    content = models.TextField(max_length=140)
```

Now I can't actually type more than 140 chars in the box - it just won't let me. Cool.

## 2.3.3 Associations has many and belongs to

In Rails you need to specify this in the model BUT when we were making our micropost model we gave it a field for user_id that was linked to the Foreign Key of auth_user. This means that this relationship already exists. More relationships can be looked up in the docs in the [model fields reference](https://docs.djangoproject.com/en/2.1/ref/models/fields/#django.db.models.ManyToManyField)

So we can do micropost.user but in order to do user.microposts we need to specify the `related_name` field so that the one to many relationship which we have in place (by giving one table a foreign key) acts in reverse too.

You can see and example [here](https://code.kodo.org.uk/dom/django/blob/38575b007a722d6af510ea46d46393a4cda9ca29/django/db/models/fields/related_descriptors.py) but in our *model.py* we essentially want the relevant line changed to this

```py
    user_id = models.ForeignKey('auth.User', related_name='microposts', on_delete=models.CASCADE)

```


# SHELL CONSOLE
see [this](https://github.com/jonathanslenders/python-prompt-toolkit/issues/25) and [this:](https://gist.github.com/Quotation/909f87320b03b028d23c)
In order to have an easy to use shell console running ptpython, in your app folder ( in this case *toy_app/* create a folder called *management* in this folder add an empty file called *__init__.py* and a folder called *__pycache__* and one called*commands* In commands you also need an *__init__.py* and a file called *shell.py* containing:

```py

from django.core.management.commands.shell import Command as ShellCommand
import os


class Command(ShellCommand):
    # ShellCommand.shells.insert(0,'ptpython')
    # Note when you define a class with brackets after then what you are doing is actually defining a subclass of what is in teh brackets - so ShellCommand here (which is actually originally Command from core/management if you look at the import) is a class that already exists. In the above commented out line I was mutating it to include ptypthon BUT its a bad idea to mutate classes so Ive used below instead:

    shells = ['ptpython'] + ShellCommand.shells

    def ptpython(self, options):
        from ptpython.repl import embed
        embed(globals(), locals(), vi_mode=False)
```

Then Append `django_extensions` to the `INSTALLED_APPS` variable in *settings.py* .

Then in your environment shell:

```sh
pip install django-extensions
```
Run the console with
```sh
python manage.py shell
or
python manage.py shell -i ptpython
```

then you want to start with :

```sh
>>> from toy_app.models import Micropost

>>> from django.contrib.auth.models import User

>>> user1 = User.objects.first()
>>> User.objects.values_list()

>>> u = User.objects.first()

>>> m = Micropost.objects.first()
## NB if this last doesn't work add a related name field to the forgein key

>>> u.microposts.all()

>>> m1 = u.microposts.first()

>>> m1.published_date
```
Look at the docs for the [Many to one relationships](https://docs.djangoproject.com/en/2.1/topics/db/examples/many_to_one/)


## Listing 2.16

here it suggests that you validate the existence of a field but Django assumes by default that a field cannot be null or blank so if you want the fields to be optional you would have to do the following in *models.py* 

```py
    published_date = models.DateTimeField(
            blank=True, null=True)
```

# Chapter 3 Mostly static pages

## 3.1 create a sample app
### Quick recap of the steps to get started:

* change directory to the your projects folder
you don't want any sqlite.db or venv files in your working directory, so why not create a new one
My shell looks like this:

```sh
al ~/projects/python-on-django/

# create new project folder and cd into it
mkdir sample-app-hartle-ror
cd sample-app-hartle-ror/

#Upgrade pip
python3 -m pip install --upgrade pip

# create a virtual environment
python3 -m venv venv

# activate venv
source venv/bin/activate.fish

#create requirements.txt containing Django version
echo "Django~=2.0.6" >> requirements.txt

#run it
pip install -r requirements.txt

# Start new sample project in current dir.
django-admin startproject sample_project .
```
* At the end of the settings.py file add the following line:

```py
STATIC_ROOT = os.path.join(BASE_DIR, 'static')
```
* scaffold the sample app

```sh
python manage.py startapp sample_app
```
* in *settings.py* add sample_app as shown:

```py
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'sample_app',
]
```

* Run admin and auth migrations

```sh
python manage.py makemigrations
python manage.py migrate
```

## 3.2 Static pages Home, Help, About

Rails uses generators to do this but Python doesn't have those so its back to the drawing board, making routes for the urls in *urls.py*, controlling them in the *views.py* with actions, and making templates in *sample_app/templates/sample_app*. Static pages aren't modelling anything so we don't need models yet.


