# Following a Rails Tutorial with Python

Following a tutorial in a language you know and converting it as you go along into a language that you *don't* know, can, I am assured, be a good way to learn a new language.

I am following the [Hartle Rails Tutorial](https://www.railstutorial.org/book/toy_app#sec-planning_the_application) In Python and I am starting from chapter 2.1 because I covered installation in *../notes.md* following the DjangoGirls Guide. I may tidy this all up later...

## 2.1 Planning the application

Generate the application skeleton (and virtual environment which is required in Python and is similar to bundler I believe)

```sh
# In your project folder create a  virtual environment
python3 -m venv venv

# Activate the virtual environment. note that for a standard bash shell, leave off .fish
source venv/bin/activate.fish

python3 -m pip install --upgrade pip

# Create a file that allows Django to be installed and run
echo "Django~=2.0.6" >> requirements.txt

# Install Django using the requirements file
pip install -r requirements.txt

# Start a Django project
django-admin startproject ror_in_python_project .
```
**NB This last command scaffolds a project. See below for scaffolding an app within that**

### Static files path

**NB _settings.py_ is like a Gemfile**

At the end of the settings.py file add the following ine:

```py
STATIC_ROOT = os.path.join(BASE_DIR, 'static')
```


**This is the actual part where we scaffold the toy app**

```sh
python manage.py startapp toy_app
```

### Listing 2.1 A Gemfile... in Python is *settings.py*
In generating the project, we have already autogenerated something like a gemfile. In it all the Python libraries and middleware are listed under `INSTALLED_APPS` and `MIDDLEWARE`

Our App we just started actually needs to be put under the list of installed apps too, like so:

```py
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'toy_app',
]
```

### Bundle install... 
We don't need to do this because running the app takes care of installing the libraries etc. BUT interestingly, Django comes with built in OAUTH. This is really cool but means that when we run the server it will tell us we have stuff in our database (OAUTH admin stuff from a Django Library) that we didn't put there and hasn't been migrated... Its ok to ignore it for now...

### Figure 2.1... versiona control and deploy all ignored.
This whole project is in version control on Github. I'm going to leave out these steps. Also deploying to Heroku... BUT IF YOU DEPLOY:

**BEFORE YOU COMMIT**
Go to *settings.py* and delete the Secret Key!!!
You can make it into an environment variable like so:

```py
SECRET_KEY = os.environ.get('SECRET')
```
And every time you want to deploy, you can make sure that your sekret key in in your environment (shell) variables by running:

```sh
export SECRET_KEY=<your-secret-key-here>
```

this makes a key available for this session and to automate this you will need a shell script or another way of doing secrets but that can come later

**NB Some of  the directories and filenames in my previous DjangoGirls tutorials and examples were renamed with an 'x' preceeding the file name so that django and Heroku don't look there for framework/etc and I am convinced that this would have been more sensibly done by moving everything to a new repo in hidsight or that there was a much better way to do this (ie put stuff in the .gitignore) but I didn't think of that...**

### Listing 2.2
This just puts something on our page when we run the server (at the moment all we would see is the Django landing page)

In rails what you see on a page that you request is controlled by, well, controllers. In Python it is handled by *views.py*

```python
from django.shortcuts import render

def hello(request):
    return render(request, 'toy_app/hello.html', {})
```
 Note that we can't just render html. Python's render shortcut requires a template. In the *toy_app* directory we need to create the following folders and file *templates/toy_app/hello.html*

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title></title>
  </head>
  <body>
    <p>hello world</p>
  </body>
</html>

```

### Listing 2.3 Setting the root route

In *urls.py* add this import to the top of the file
```py
from django.urls import path, include
from django.contrib import admin
```
Then in the `urlpatterns` list add:

```py
    path('', include('toy_app.urls')),
```
Then (so things are kept neat if there are other apps etc, go into the toy_app directory and create *toy_app/urls.py* as follows:

```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.hello, name='hello'),
]
```

Now check it works... 

```sh
python manage.py runserver
```

you'll see some error messages about migrating things like admin etc BUT if you point your browser to `http://localhost:8000/` you should see the text 'hello world'.

## 2.1.1 A toy model for users

A cool thing about Django is that it assumes you want users and OAUTH and logins and passwords... so you just get them out of the box. This is that admin library that has been mentioned. So to get all that stuff all you do is make and run your migrations and it will appear... so actually no code here... on to the next step

## 2.1.2 A toy model for microposts

All that the ROR tutorial wants you to have in this model is a user, and content as a text field. So lets model this in *models.py*

```py
from django.db import models

class Micropost(models.Model):
    user_id = models.ForeignKey('auth.User', on_delete=models.CASCADE)
    text = models.TextField()

    def publish(self):
        self.save()
```

On line 1 we import the Django db models library. We define our model as a class called MicroPost which inherits from the imported Django models.Model. The only things a model needs now are fields. In a database this would look like a table called Microposts with two columns, one called user_id and one called text. In Python you have to then assign a database field type for the database (and these come from the Field class and you can see types [here](https://docs.djangoproject.com/en/2.1/ref/models/fields/#model-field-types)

In the case of the column I've called user_id (could be called author too if preferred) the field type is actually going to be a user and we already *have* users model provided by the admin/auth library, so we want this column to be linked to another table - the user table. To do this we use a models.ForeignKey field defined as `class ForeignKey(to, on_delete, **options)[source]` and use the standard kind of CASCADE delete. Because the User class is in the auth library not in this file we need to refer to it as `auth.User' 

The next column is simpler, it is just called text and is a TextField in the database.

I have used a very simple publish methid of just saving the instance (self).

## Listing 2.4: Migrating the database

```sh
# admin and auth migrations
python manage.py makemigrations
python manage.py migrate
# our migrations
python manage.py makemigrations toy_app
python manage.py migrate toy_app

# run server

```sh
python manage.py runserver
```




